
#### **Ключевое слово inline. Цель добавления. Сравнение с макросами**

`inline` - пожелание компилятору заменить вызовы функции последовательной вставкой кода самой функции

```c
inline double average(double a, double b)
{
	return (a + b) / 2;
}
```

В С99 `inline`-реализация не предоставляет и не запрещает реализацию со внешней линковкой. `inline` означает, что определение функции предоставляется только для подстановки и где-то в программе должно быть другое такое же определение этой же функции.

```c
inline int add(int a, int b) 
{
	return a + b;
}

int main(void)
{
	int i = add(4, 5);
	return i;
}
// main.c:(.text+0x1e): undefined reference to `add'
// collect2.exe: error: ld returned 1 exit status
```

#### **Способы исправления проблемы «unresolved reference»**

- использовать ключевое слово `static`. Такая функция доступна только в текущей единице трансляции.

```c
static inline int add(int a, int b) 
{
	return a + b;
}

int main(void)
{
	int i = add(4, 5);
	return i;
}
```

- использовать ключевое слово `extern`. Такая функция доступна из других единиц трансляции.

```c
extern inline int add(int a, int b) 
{
	return a + b;
}

int main(void)
{
	int i = add(4, 5);
	return i;
}
```

- Добавить еще одно такое же `не-inline` определение функции где-нибудь в программе. Самый плохой способ решения проблемы, потому что реализации могут не совпасть.
- Не использовать `inline`: компиляторы и так могут оптимизировать функции.

```c
int add(int a, int b) 
{
	return a + b;
}

int main(void)
{
	int i = add(4, 5);
	return i;
}
```

`inline` был введен в С99 как с целью **оптимизации производительности** за счет накладных расходов на вызов функции. До этого программисты часто пользовались макросами для решения похожих задач, но макросы имеют недостатки (отсутствие контроля типов, непредсказуемое поведение при использовании сложных выражений, сложность отладки). `inline` - это безопасная альтернатива макросам.