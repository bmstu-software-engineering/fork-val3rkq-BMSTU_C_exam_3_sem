- АТД, модуль, разновидности модулей, АО - стек целых чисел
- АТД, модуль, разновидности модулей, АТД - стек целых чисел
---
#### **Модуль и его разновидности**

**Программу удобно рассматривать как набор независимых модулей.**

- *Модуль* состоит из двух частей: интерфейса (он один) и реализации (может быть несколько).
- *Интерфейс* описывает, `что модуль делает`. Он определяет идентификаторы, типы и подпрограммы, которые будут доступны коду, использующему этот модуль.
- *Реализация* описывает, `как модуль выполняет то, что предлагает интерфейс`. 
- Часть кода, которая использует модуль, называют *клиентом*. 
- Клиент должен зависеть только от интерфейса, но не от деталей его реализации.

**В языке Си интерфейс описывается в заголовочном файле (*.h).**

- В заголовочном файле описываются макросы, типы, переменные и функции, которые клиент может использовать.
- Клиент импортирует интерфейс с помощью директивы препроцессора include.
- Реализация интерфейса в языке Си представляется одним или несколькими файлами с расширением *.c
- Реализация определяет переменные и функции, необходимые для обеспечения возможностей, описанных в интерфейсе.
- Реализация обязательно должна включать файл описания интерфейса, чтобы гарантировать согласованность интерфейса и реализации

**Преимущества использования модулей:**

- Абстракция (как средство борьбы со сложностью)
`Когда интерфейсы модулей согласованы, ответственность за реализацию каждого модуля делегируется определенному разработчику.`

- Повторное использование
`Модуль может быть использован в другой программе.`

- Сопровождение
`Можно заменить реализацию любого модуля, например, для улучшения производительности или переноса программы на другую платформу`

#### **Типы модулей**

- **Набор данных**
Набор связанных переменных и/или констант. В Си модули этого типа часто
представляются только заголовочным файлом. (`float.h`, `limits.h`)

- **Библиотека**
Набор связанных функций

- **Абстрактный объект**
Набор функций, который обрабатывает скрытые данные.

- **Абстрактный тип данных**
Интерфейс, который определяет тип данных и операции над этим типом. Тип данных называется абстрактным, потому что интерфейс скрывает детали его представления и реализации.

#### **Пример АО стек целых чисел**

```c
#ifndef __STACK__O__H__
#define __STACK__O__H__

#include <stdbool.h>

void make_empty(void);
bool is_empty(void);
bool is_full(void);
int push(int i);
int pop(int *i);

#endif // __STACK__O__H__
```

```c
#include <stddef.h>
#include "stack_ao.h"

#define STACK_SIZE 10

static int content[STACK_SIZE];
static size_t top;

void make_empty(void)
{
	top = 0;
}

bool is_empty(void)
{
	return top == 0;
}

bool is_full(void)
{
	return top >= STACK_SIZE;
}

int push(int i)
{
	if (is_full())
		return 1;
	content[top++] = i;
	return 0;
}

int pop(int *i)
{
	if (is_empty())
		return 1;
	*i = content[--top];
	return 0;
}
```

#### **Неполный тип в Си**

Стандарт Си описывает неполные типы как «типы, которые описывают объект, но не предоставляют информацию нужную для определения его размера». `struct t;`
- Пока тип неполный его использование ограничено.
- Описание неполного типа должно быть закончено где-то в программе
- Допустимо определять указатель на неполный тип `typedef struct t *T;`

**Можно:**
- определять переменные типа *T*
- передавать эти переменные как аргументы в функцию

**Нельзя:**
- применять операцию обращения к полю (->);
- разыменовывать переменные типа *T*

#### **Пример АТД стек целых чисел**

```c
#ifndef __STACK__H__
#define __STACK__H__

#include <stdbool.h>

typedef struct stack_type *stack_t;

void make_empty(stack_t s);
bool is_empty(const stack_t s);
bool is_full(const stack_t s);
int push(stack_t s, int i);
int pop(stack_t s, int *i);

stack_t create(void);
void destroy(stack_t s);

#endif // __STACK__H__
```

```c
#include <assert.h>
#include <stddef.h>
#include "stack.h"

#define STACK_SIZE 10

struct stack_type
{
	int content[STACK_SIZE];
	size_t top;
}

stack_t create(void)
{
	stack_t s = malloc(sizeof(struct stack_type));
	if (s)
		make_empty(s);
	return s;
}

void destroy(stack_t s)
{
	free(s);
}

void make_empty(stack_t s)
{
	assert(s);
	s->top = 0;
}

bool is_empty(const stack_t s)
{
	assert(s);
	return s->top == 0;
}

bool is_full(const stack_t s)
{
	assert(s);
	return s->top >= STACK_SIZE;
}

int push(stack_t s, int i)
{
	assert(s);
	if (is_full(s))
		return 1;
	s->content[(s->top)++] = i;
	return 0;
}

int pop(stack_t s, int *i)
{
	assert(s);
	if (is_empty(s))
		return 1;
	*i = s->content[--(s->top)];
	return 0;
}
```