
#### **VLA**

Появились в С99.

```c
scanf("%d", &n);
int a[n];
```

- Длина такого массива вычисляется во время выполнения программы, а не во время компиляции. 
- Память под элементы массива выделяется на стеке. 
- Массивы переменного размера нельзя инициализировать при определении. 
- Массивы переменной длины могут быть многомерными. 
- Адресная арифметика справедлива для массивов переменной длины. 
- Массивы переменной длины облегчают описание заголовков функций, которые обрабатывают массивы.

#### **alloca**

```c
#include <alloca.h>

void *alloca(size_t size);
```

- Функция *alloca* выделяет область памяти, размером size байт, на стеке.
- Функция возвращает указатель на начало выделенной области. 
- Эта область автоматически освобождается, когда функция, которая вызвала *alloca*, возвращает управления вызывающей стороне. 
- Если выделение вызывает переполнение стека, поведение программы не определено.

```c
scanf("%d", &n);
int *a = alloca(n * sizeof(int));

for (int i = 0; i < n; i++)
	a[i] = i;
```

`+`:
- Выделение происходит быстро
- Выделенная область освобождается автоматически

`-`:
- функция нестандартная
- серьезные ограничения по размеру области

```c
// VLA, когда тело цикла закончится, массив разрушится (т.к. переменная вышла из области видимости)
void foo(int size)
{
	...
	while (b)
	{
		char tmp[size];
		...
	}
}

// alloca, массив выделится, но память останется до конца работы функции и легко получить переполнение стека
void foo(int size)
{
	...
	while (b)
	{
		char *tmp = alloca(size);
		...
	}
}
```