
`[]` - массив типа …
`[N]` - массив из **N** элементов типа …
`(type)` - функция, принимающая аргумент типа *type* и возвращающая …
`*` - указатель на … 

Читать нужно изнутри наружу (т.е. с имени сущности). Или же: двигаемся вправо пока можем, иначе влево. Отправная точка - идентификатор.
Нужно отдавать предпочтение `[]` и `()`, а не `*`

```text
*name[] - массив типа, а не указатель на ...
*name() - функция, принимающая, а не указатель на ...
```

#### **Примеры**

```text
long **foo[7] - массив из 7 элементов типа указатель на указатель на long

int *(*x[10])(int, int) - массив из 10 элементов типа указатель на функцию, которая принимает два аргумента типа int и возвращает указатель на int.

char *(*(**foo[][8])())[] - массив типа массив из 8 элементов типа указатель на указатель на функцию, которая ничего не принимает и возвращает указатель на массив типа указатель на char
```

#### **Семантические ограничения**

- невозможно создать массив функций

```c
int a[10](int);
```

- функция не может возвращать функцию

```c
int g(int)(int);
```

- функция не может вернуть массив 

```c
int f(int)[];
```

- для массива только левая лексема `[]` может быть пустой

```c
int a[][];
```

- тип *void* ограниченный

```c
void x;
void x[5];
```

#### **Использование typedef**

```c
int *(*x[10])(void);

typedef int *func_t(void);
typedef func_t *func_ptr;
typedef func_ptr func_ptr_arr[10];

func_ptr_arr x;
```
