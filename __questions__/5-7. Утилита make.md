- Утилита make, назначение. Простой сценарий сборки
- Утилита make, назначение, переменные, шаблонные правила
- Утилита make, назначение, условные конструкции, анализ зависимостей
---
#### **Общее**

**make** — утилита, автоматизирующая процесс преобразования файлов из одной формы в другую.

###### **Принцип работы** 

Необходимо создать так называемый сценарий сборки проекта *Makefile*. Этот файл описывает: 
	- отношения между файлами программы; 
	- содержит команды для обновления каждого файла.

Утилита *make* использует информацию из *Makefile* и время последнего изменения каждого файла для того, чтобы решить, какие файлы нужно обновить. 

###### **Разновидности**

- GNU Make (рассматривается далее)
- BSD Make
- Microsoft Make (nmake)

###### **Сценарий сборки**

Содержит переменные и правила, из каких составных частей, назначения у правил.

```Makefile
зависимость_1 ... зависимость_n 
	команда_1 
	команда_2 
	...
	команда_m
```

`что создать/сделать: из чего создать 
	`как создать/что сделать`

###### **Особенности выполнения команд**

- Ненулевой код возврата может прервать выполнение сценария.
- Каждая команда выполняется в своем shell.

#### **Простой сценарий сборки (5)**

```Makefile
greeting.exe: hello.o bye.o main.o
	gcc -o greeting.exe hello.o bye.o main.o

hello.o: hello.c hello.h
	gcc -std=c99 -Wall -Werror -Wpedantic -c hello.c

bye.o: bye.c bye.h
	gcc -std=c99 -Wall -Werror -Wpedantic -c bye.c

main.o: main.c hello.h bye.h
	gcc -std=c99 -Wall -Werror -Wpedantic -c main.c

clean:
	rm *.o *.exe
```

Как *make* будет его обрабатывать:

1) **если проект не собирался ранее**
	make читает сценарий сборки и начинает выполнять первое правило *greeting.exe*. Для его выполнения необходимо сначала обработать зависимости, поэтому make ищет правила для создания *hello.o*, *bye.o*, *main.o*. 

	Файл *hello.o* отсутствует, файлы *hello.c* и *hello.h* существуют. Следовательно, правило для создания *hello.o* может быть выполнено.

	Аналогично обрабатываются остальные зависимости.
	
	Эти правила могут быть выполнены. Все зависимости получены, теперь правило для построения greeting.exe может быть выполнено.
	
2) **проект собирался ранее, но после этого был изменен файл hello.o***
	make читает сценарий сборки и начинает выполнять первое правило *greeting.exe*. Для его выполнения необходимо сначала обработать 
	зависимости, поэтому make ищет правила для создания *hello.o*, *bye.o*, *main.o*. 
	
	Файлы hello.o, hello.c и hello.h существуют, но время изменения hello.o меньше времени изменения hello.c. Придется пересоздать файл hello.o

	Аналогично обрабатываются зависимости bye.o и main.o, но эти файлы были изменены позже соответствующих си-файлов, т.е. ничего делать не нужно.
	
	Все зависимости получены. Время изменения greeting.exe меньше времени изменения hello.o. Придется пересоздать greeting.exe

###### **Ключи запуска утилиты**

- Ключ «-f» используется для указания имени файла сценария сборки

```bash
make -f makefile_2
```

- Ключ «-B» используется для безусловного выполнения правил

```bash
make -B
```

- Ключ «-n» используется для вывода команд без их выполнения

```bash
make –n
```

- Ключ «-i» используется для игнорирования ошибок при выполнении команд

```bash
make -i
```

#### **Переменные, шаблонные правила (6)**

Определить переменную в make-файле можно следующим образом:

```Makefile
VAR_NAME := value
```

Чтобы получить значение переменной, необходимо ее имя заключить в круглые
скобки и перед ними поставить символ `$`. Строки, которые начинаются с символа `#`, являются комментариями.

```Makefile
# Компилятор
CC := gcc

# Опции компиляции
CFLAGS := -std=c99 -Wall -Werror -Wpedantic

...
main.o: main.c list.h
	$(CC) $(CFLAGS) -I inc -c main.c -o main.o
```

###### **Неявные правила**

В примере *main.o* создастся неявно без правила

```Makefile
app.exe: $(OBJS) main.o
	$(CC) -o greeting.exe $(OBJS) main.o
```

- Ключ «-p» показывает неявные правила и переменные. 
- Ключ «-r» запрещает использовать неявные правила.

###### **Фиктивные цели**

Чтобы make даже не пытался интерпретировать *фиктивные* цели как имена файлов их помечают атрибутом **.PHONY**.

```Makefile
.PHONY: clean
```

###### **Автоматические переменные**

**Автоматические переменные** - это переменные со специальными именами, которые «автоматически» принимают определенные значения перед выполнением описанных в правиле команд.

- Переменная **$ˆ** означает *список зависимостей*.
- Переменная **$@** означает *имя цели*.
- Переменная **$<** означает *первую зависимость*.

```Makefile
# было
greeting.exe: $(OBJS) main.o
	$(CC) -o greeting.exe $(OBJS) main.o

# стало
greeting.exe: $(OBJS) main.o
	$(CC) -o $@ $^
```


```Makefile
# было
hello.o: hello.c hello.h
	$(CC) $(CFLAGS) -c hello.c

# стало
hello.o: hello.c hello.h
	$(CC) $(CFLAGS) -c $<
```

###### **Шаблонные правила**

`%` задает зависимость от подстановки в цели.

```Makefile
%.расш_файлов_целей: %.расш_файлов_зависимостей
	команда_1
	команда_2

	...
	команда_m
```

в правилах задает зависимость от всех файлов по маске

```Makefile
%.o: %.c *.h
	$(CC) $(CFLAGS) -c $<
```

#### **Условные конструкции, анализ зависимостей (7)**

###### **Условные конструкции**

```Makefile
ifeq ($(mode), debug)
	CFLAGS += -g3
endif
```

###### **Переменные, зависящие от цели**

```Makefile
debug: CFLAGS += -g3
debug: app.exe

release: CFLAGS += -DNDEBUG -g0
release: app.exe
```

###### **Автоматическая генерация зависимостей**

Ручная установка зависимостей

```Makefile
%.o: %.c %.h
	$(CC) -c $(CFLAGS) $< -o $@
```

С помощью компилятора

```Makefile
# c-файлы
SRCS := ...

%.o: %.c
	$(CC) $(CFLAGS) -c $<
%.d: %.c
	$(CC) -M $< > $@

include $(SRCS:.c=.d)
```

###### **Функции в make**

Вызов функции 

```Makefile
$(function_name [arguments])
```

Функция **patsubs**

```Makefile
$(patsubst pattern, replacement, text)
cfiles := main.c hello.c bye.c

# полная форма
objs := $(patsubst %.c, %.o, $(cfiles))

# краткая форма
objs := $(cfiles:%.c=%.o)
```