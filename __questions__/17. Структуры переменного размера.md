
#### **Структуры переменного размера (примеры)**

*TLV* (Type (или Tag) Length Value) - схема кодирования произвольных данных в некоторых телекоммуникационных протоколах.
- Type – описание назначения данных.
- Length – размер данных (обычно в байтах).
- Value – данные.
Первые два поля имеют фиксированный размер.

TLV кодирование *используется* в:
- семействе протоколов TCP/IP
- спецификация PC/SC (smart cards)
- ASN.1
- …

Преимущества TLV кодирования:
- простота разбора;
- «тройки» TLV c неизвестным типом (тегом) могут быть пропущены при разборе;
- «тройки» TLV могут размещаться в произвольном порядке;
- «тройки» TLV обычно кодируются двоично, что позволяет выполнять разбор быстрее и требует меньше объема по сравнению с кодированием, основанном на текстовом представлении.

#### **Flexible array member (C99)**

```c
struct s
{
	int n;
	double d[];
}
```

- подобное поле должно быть последним
- нельзя создавать массив структур с таким полем
- структура с таким полем не может использоваться как член в "середине" другой структуры
- операция *sizeof* не учитывает размер этого поля (возможно, за исключением выравнивания)
- если в этом массиве нет элементов, то обращение к его элементам - UB

```c
struct s
{
	int n;
	double d[];
}

struct s *create_s(int n, const double *d)
{
	assert(n >= 0);

	struct s *elem = malloc(sizeof(struct s) + n * sizeof(double));
	if (elem)
	{
		elem->n = n;
		memmove(elem->d, d, n * sizeof(double));
	}

	return elem;
}
```

#### **Flexible array member (до C99)**

```c
struct s
{
	int n;
	double d[1];
}

struct s *create_s(int n, const double *d)
{
	assert(n >= 0);

	// чтобы успокоить valgrind
	struct s *elem = calloc(sizeof(struct s) + 
										(n > 1 ? (n - 1) * sizeof(double) : 0), 1);
	if (elem)
	{
		elem->n = n;
		memmove(elem->d, d, n * sizeof(double));
	}

	return elem;
}
```

#### **Flexible array member VS поле с обычным указателем**

- экономия памяти
- локальность данных
- атомарность выделения памяти
- не требует "глубокого копирования" и освобождения